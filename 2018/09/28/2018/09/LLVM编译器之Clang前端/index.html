<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>LLVM编译器之Clang前端 | Bryan Yang</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="嗨，我是杨彪，一名iOS开发者，正在探索iOS求学之道。路漫漫兮修远兮，吾将上下而求索。">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="LLVM编译器之Clang前端 | Bryan Yang">
    <meta name="twitter:description" content="嗨，我是杨彪，一名iOS开发者，正在探索iOS求学之道。路漫漫兮修远兮，吾将上下而求索。">

    <meta property="og:type" content="article">
    <meta property="og:title" content="LLVM编译器之Clang前端 | Bryan Yang">
    <meta property="og:description" content="嗨，我是杨彪，一名iOS开发者，正在探索iOS求学之道。路漫漫兮修远兮，吾将上下而求索。">

    
    <meta name="author" content="Bryan Yang">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://xxzizixx.github.io/2018/09/28/2018/09/LLVM编译器之Clang前端/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Bryan Yang 的主页"><img src="/images/avatar.jpg" width="80" alt="Bryan Yang logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Bryan Yang">Bryan Yang</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">其修远兮，上下求索</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">嗨，我是杨彪，一名iOS开发者，正在探索iOS求学之道。路漫漫兮修远兮，吾将上下而求索。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/xxzizixx" title="查看我的GitHub主页" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-09-28T08:24:17.000Z" class="post-list__meta--date date">2018-09-28</time> &#8226; <span class="post-meta__tags tags"> 
  
 </span>
    </div>
    <h1 class="post-title">LLVM编译器之Clang前端</h1>
  </header>

  <section class="post">
    <h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><blockquote>
<h3 id="瞻仰大佬"><a href="#瞻仰大佬" class="headerlink" title="瞻仰大佬"></a>瞻仰大佬</h3></blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/30/166281ae1b5a9f6a?w=314&amp;h=328&amp;f=jpeg&amp;s=39409" alt=""><br><strong><center>Chris Lattner</center></strong></p>
<h3 id="三大杰作："><a href="#三大杰作：" class="headerlink" title="三大杰作："></a>三大杰作：</h3><blockquote>
<ul>
<li><strong>Clang</strong></li>
<li><strong>LLVM</strong></li>
<li><strong>Swift</strong></li>
</ul>
</blockquote>
<p>2010年开始编写 Swift语言,而且一个人实现了Swift的大部分基础架构；他也是 LVVM 以及 Clang的主要开发者。<br><br><br></p>
<h1 id="什么是LLVM"><a href="#什么是LLVM" class="headerlink" title="什么是LLVM"></a>什么是LLVM</h1><p><a href="https://llvm.org/" target="_blank" rel="noopener">LLVM官网</a></p>
<ul>
<li>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.</li>
<li>LLVM是一个模块化和可重用的编译器和工具链技术的集合。</li>
</ul>
<p><strong>作用</strong>：用于优化以任意程序语言编写的程序的<strong>编译时间(compile-time)</strong>、<strong>链接时间(link-time)</strong>、<strong>运行时间(run-time)</strong>以及<strong>空闲时间(idle-time)</strong>.在2000年,Chris Lattner开发了这一套编译器工具库套件.后来随着LLVM的发展,LLVM可以用于常规编译器,JIT编译器,汇编器,调试器,静态分析工具等一系列跟编程语言相关的工作。  </p>
<p>2012年，LLVM 获得<strong>美国计算机学会 ACM</strong> 的软件系统大奖，和 <strong>UNIX，WWW，TCP/IP，Apache，JAVA, Eclipse</strong>等齐名。</p>
<p><strong>注</strong>：LLVM工程包含了一组模块化，可复用的编辑器和工具链。同其名字原意(Low Level Virtual Machine)不同的是，LLVM不是一个首字母缩写，而是工程的名字。<br><br><br></p>
<h2 id="Xcode版本的相对应编译器的变迁"><a href="#Xcode版本的相对应编译器的变迁" class="headerlink" title="Xcode版本的相对应编译器的变迁"></a>Xcode版本的相对应编译器的变迁</h2><table>
<thead>
<tr>
<th style="text-align:center">Xcode版本</th>
<th style="text-align:center">编译器版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Xcode3之前</td>
<td style="text-align:center">GCC</td>
</tr>
<tr>
<td style="text-align:center">Xcode3</td>
<td style="text-align:center">GCC与 LLVM混合编译器</td>
</tr>
<tr>
<td style="text-align:center">Xcode4</td>
<td style="text-align:center">LLVM-GCC 成为默认编译器</td>
</tr>
<tr>
<td style="text-align:center">Xcode4.2</td>
<td style="text-align:center">LLVM3.0成为默认编译器</td>
</tr>
<tr>
<td style="text-align:center">Xcode5</td>
<td style="text-align:center">LLVM5.0, 完成 GCC到LLVM的过渡</td>
</tr>
</tbody>
</table>
<h3 id="GCC-gt-LLVM-简介"><a href="#GCC-gt-LLVM-简介" class="headerlink" title="GCC -&gt; LLVM 简介"></a>GCC -&gt; LLVM 简介</h3><blockquote>
<p>GCC是 Xcode早期使用的一个强大的编译器.这个编译器被移植到各种系统中,其中就是 Mac OSX 操作系统,所以这就反映在 Xcode中,在早期的 Xcode 调试代码的一个工具就是 GDB,它是GNU调试器.  </p>
</blockquote>
<h3 id="为什么从GCC变迁到LLVM？"><a href="#为什么从GCC变迁到LLVM？" class="headerlink" title="为什么从GCC变迁到LLVM？"></a>为什么从GCC变迁到LLVM？</h3><p>Apple(包括中后期的NeXT)一直使用GCC作为官方的编译器。GCC作为开源世界的编译器标准一直做得不错,但Apple对编译工具会提出更高的要求。<br>一方面,是Apple对Objective-C语言(甚至后来对C语言)新增很多特性,但GCC开发者并不买Apple的帐——不给实现,因此索性后来两者分成两条分支分别开发,这也造成Apple的编译器版本远落后于GCC的官方版本。另一方面,GCC的代码耦合度太高,不好独立,而且越是后期的版本,代码质量越差,但Apple想做的很多功能(比如更好的IDE支持)需要模块化的方式来调用GCC,但GCC一直不给做。甚至最近,<a href="https://blog.delphij.net/2009/01/gcc.html" target="_blank" rel="noopener">《GCC运行环境豁免条款(英文版)》</a>从根本上限制了LLVM-GCC的开发。 所以,这种不和让Apple一直在寻找一个高效的、模块化的、协议更放松的开源替代品.<br><br><br></p>
<h3 id="目前LLVM包含的主要子项目包括"><a href="#目前LLVM包含的主要子项目包括" class="headerlink" title="目前LLVM包含的主要子项目包括:"></a>目前LLVM包含的主要子项目包括:</h3><blockquote>
<ol>
<li>LLVM Core:包含一个现在的源代码/目标设备无关的优化器，一集一个针对很多主流(甚至于一些非主流)的CPU的汇编代码生成支持。</li>
<li>Clang:一个C/C++/Objective-C编译器，致力于提供令人惊讶的快速编译，极其有用的错误和警告信息，提供一个可用于构建很棒的源代码级别的工具.</li>
<li>dragonegg: gcc插件，可将GCC的优化和代码生成器替换为LLVM的相应工具。</li>
<li>LLDB:基于LLVM提供的库和Clang构建的优秀的本地调试器。</li>
<li>libc++、libc++ ABI: 符合标准的，高性能的C++标准库实现，以及对C++11的完整支持。</li>
<li>compiler-rt:针对__fixunsdfdi和其他目标机器上没有一个核心IR(intermediate representation)对应的短原生指令序列时，提供高度调优过的底层代码生成支持。</li>
<li>OpenMP: Clang中对多平台并行编程的runtime支持。</li>
<li>vmkit:基于LLVM的Java和.NET虚拟机实</li>
<li>polly: 支持高级别的循环和数据本地化优化支持的LLVM框架。</li>
<li>libclc: OpenCL标准库的实现</li>
<li>klee: 基于LLVM编译基础设施的符号化虚拟机</li>
<li>SAFECode:内存安全的C/C++编译器</li>
<li>lld: clang/llvm内置的链接器</li>
</ol>
</blockquote>
<p><br><br></p>
<h1 id="LLVM编译架构"><a href="#LLVM编译架构" class="headerlink" title="LLVM编译架构"></a>LLVM编译架构</h1><p>传统的静态编译器分为三个阶段：前端、优化和后端。<br><img src="https://user-gold-cdn.xitu.io/2018/9/30/166296aeeb3c3a13" alt=""></p>
<p><strong>典型例子：GCC编译器， 如何做到解耦？</strong><br><img src="https://user-gold-cdn.xitu.io/2018/10/8/166528b84aef2c59?w=860&amp;h=74&amp;f=jpeg&amp;s=14953" alt=""></p>
<h3 id="LLVM-Three-Phase-编译器器架构"><a href="#LLVM-Three-Phase-编译器器架构" class="headerlink" title="LLVM Three-Phase 编译器器架构:"></a>LLVM Three-Phase 编译器器架构:</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/30/166296b4f9fb0116" alt=""></p>
<h4 id="架构优点："><a href="#架构优点：" class="headerlink" title="架构优点："></a>架构优点：</h4><blockquote>
<p> 不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)<br><br><br><br> 如果需要支持一种新的编程语言，那么只需要实现一个新的前端<br><br><br><br> 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端<br><br><br><br> 优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改<br><br><br><br> LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)  </p>
</blockquote>
<p><br>  </p>
<h3 id="Clang-Swift-LLVM-编译器器架构"><a href="#Clang-Swift-LLVM-编译器器架构" class="headerlink" title="Clang/Swift - LLVM 编译器器架构:"></a>Clang/Swift - LLVM 编译器器架构:</h3><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/166528aee2e388d5?w=854&amp;h=487&amp;f=jpeg&amp;s=95419" alt=""></p>
<p><strong>Frontend:前端</strong></p>
<ul>
<li>词法分析、语法分析、语义分析、生成中间代码</li>
</ul>
<p><strong>Optimizer:优化器</strong></p>
<ul>
<li>中间代码优化</li>
</ul>
<p><strong>Backend:后端</strong></p>
<ul>
<li>生成机器码<br><br><br></li>
</ul>
<p>作为LLVM提供的编译器前端，clang可将用户的源代码(C/C++/Objective-C)编译成语言/目标设备无关的IR(Intermediate Representation)实现。其可提供良好的插件支持，容许用户在编译时，运行额外的自定义动作。<br><br><br></p>
<h1 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h1><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a03c909b56aad?w=1200&amp;h=579&amp;f=jpeg&amp;s=116720" alt=""></p>
<p><br><br></p>
<h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#define DEFINEEight 8</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">int eight = DEFINEEight;</span><br><span class="line">int six = 6;</span><br><span class="line">NSString* site = [[NSString alloc] initWithUTF8String:&quot;starming&quot;];</span><br><span class="line">int rank = eight + six;</span><br><span class="line">NSLog(@&quot;%@ rank %d&quot;, site, rank);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>查看oc的c实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m -o main-arm64.cpp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>生成的c++文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">int eight = 8;</span><br><span class="line">int six = 6;</span><br><span class="line">NSString* site = ((NSString * _Nullable (*)(id, SEL, const char * _Nonnull))(void *)objc_msgSend)((id)((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;initWithUTF8String:&quot;), (const char *)&quot;starming&quot;);</span><br><span class="line">int rank = eight + six;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_c__8jb7vhc96p1bhvf5gl7zw_9sj925cz_T_main_9c278d_mi_0, site, rank);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure></p>
<p><br>  </p>
<h2 id="Clang-命令"><a href="#Clang-命令" class="headerlink" title="Clang 命令"></a>Clang 命令</h2><ul>
<li>Clang 在概念上是编译器前端，同时，在命令行中也作为一个“黑盒”的 Driver。  </li>
<li>封装了了编译管线、前端命令、LLVM 命令、Toolchain 命令等，一<br>个 Clang ⾛走天下。  </li>
<li>⽅便从 gcc 迁移过来。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/8/1665299812d333a9?w=480&amp;h=220&amp;f=jpeg&amp;s=15434" alt=""><br>例如上面的查看oc的c语言实现，可以利用clang重写objc：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc mian.m</span><br></pre></td></tr></table></figure></p>
<h3 id="利用clang命令查看整个编译过程"><a href="#利用clang命令查看整个编译过程" class="headerlink" title="利用clang命令查看整个编译过程"></a>利用clang命令查看整个编译过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -ccc-print-phases main.m</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到编译源文件需要的几个不同的阶段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: input, &quot;main.m&quot;, objective-c</span><br><span class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output // 预处理    </span><br><span class="line">2: compiler, &#123;1&#125;, ir    // 编译生成IR(中间代码)</span><br><span class="line">3: backend, &#123;2&#125;, assembler  // 汇编器生成汇编代码</span><br><span class="line">4: assembler, &#123;3&#125;, object   // 生成机器码(目标文件)</span><br><span class="line">5: linker, &#123;4&#125;, image   // 链接</span><br><span class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image  // 根据运行平台，生成镜像文件(Image)，也就是最后的可执行文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>想看清clang前端的全部过程？接下来可以继续通过clang命令查看各阶段都做了哪些处理。</p>
<p><br></p>
<h3 id="1⃣-Preprocess-预处理"><a href="#1⃣-Preprocess-预处理" class="headerlink" title="1⃣ Preprocess -预处理"></a>1⃣ Preprocess -预处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -E main.m</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">... 头文件</span><br><span class="line"></span><br><span class="line"># 1 &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h&quot; 1 3</span><br><span class="line"># 185 &quot;/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&quot; 2 3</span><br><span class="line"># 2 &quot;main.m&quot; 2</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">int eight = 8;</span><br><span class="line">int six = 6;</span><br><span class="line">NSString* site = [[NSString alloc] initWithUTF8String:&quot;starming&quot;];</span><br><span class="line">int rank = eight + six;</span><br><span class="line">NSLog(@&quot;%@ rank %d&quot;, site, rank);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程的处理包括宏的替换，头文件的导入，以及类似#if的处理。</p>
<p><br></p>
<h3 id="2⃣-Lexical-Analysis-词法分析"><a href="#2⃣-Lexical-Analysis-词法分析" class="headerlink" title="2⃣ Lexical Analysis - 词法分析"></a>2⃣ Lexical Analysis - 词法分析</h3><ul>
<li>词法分析，也作 Lex 或者 Tokenization  </li>
<li>将预处理理过的代码⽂文本转化成 Token 流</li>
<li>不校验语义  <blockquote>
<p>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p><br></p>
<h3 id="3⃣-Semantic-Analysis-语法分析"><a href="#3⃣-Semantic-Analysis-语法分析" class="headerlink" title="3⃣ Semantic Analysis - 语法分析"></a>3⃣ Semantic Analysis - 语法分析</h3><ul>
<li>语法分析，在 Clang 中由 Parser 和 Sema 两个模块配合完<br>成</li>
<li>验证语法是否正确</li>
<li>根据当前语⾔言的语法，⽣生成语意节点，并将所有节点组合成 抽象语法树(AST)  </li>
</ul>
<p>如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int testAST(int a, int b) &#123;</span><br><span class="line">while (b != 0) &#123;</span><br><span class="line"></span><br><span class="line">if (a &gt; b) &#123;</span><br><span class="line">a = a - b;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">b = b - a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure></p>
<p>生成如下语法树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">`-FunctionDecl 0x7ffd8f84d678 &lt;main.m:3:1, line:13:1&gt; line:3:5 test &apos;int (int, int)&apos;</span><br><span class="line">|-ParmVarDecl 0x7ffd8f84d4f8 &lt;col:10, col:14&gt; col:14 used a &apos;int&apos;</span><br><span class="line">|-ParmVarDecl 0x7ffd8f84d570 &lt;col:17, col:21&gt; col:21 used b &apos;int&apos;</span><br><span class="line">`-CompoundStmt 0x7ffd8f84dba8 &lt;col:24, line:13:1&gt;</span><br><span class="line">|-WhileStmt 0x7ffd8f84db30 &lt;line:4:5, line:11:5&gt;</span><br><span class="line">| |-&lt;&lt;&lt;NULL&gt;&gt;&gt;</span><br><span class="line">| |-BinaryOperator 0x7ffd8f84d7d8 &lt;line:4:12, col:17&gt; &apos;int&apos; &apos;!=&apos;</span><br><span class="line">| | |-ImplicitCastExpr 0x7ffd8f84d7c0 &lt;col:12&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">| | | `-DeclRefExpr 0x7ffd8f84d778 &lt;col:12&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d570 &apos;b&apos; &apos;int&apos;</span><br><span class="line">| | `-IntegerLiteral 0x7ffd8f84d7a0 &lt;col:17&gt; &apos;int&apos; 0</span><br><span class="line">| `-CompoundStmt 0x7ffd8f84db10 &lt;col:20, line:11:5&gt;</span><br><span class="line">|   `-IfStmt 0x7ffd8f84dad8 &lt;line:6:9, line:10:9&gt;</span><br><span class="line">|     |-&lt;&lt;&lt;NULL&gt;&gt;&gt;</span><br><span class="line">|     |-&lt;&lt;&lt;NULL&gt;&gt;&gt;</span><br><span class="line">|     |-BinaryOperator 0x7ffd8f84d880 &lt;line:6:13, col:17&gt; &apos;int&apos; &apos;&gt;&apos;</span><br><span class="line">|     | |-ImplicitCastExpr 0x7ffd8f84d850 &lt;col:13&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|     | | `-DeclRefExpr 0x7ffd8f84d800 &lt;col:13&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d4f8 &apos;a&apos; &apos;int&apos;</span><br><span class="line">|     | `-ImplicitCastExpr 0x7ffd8f84d868 &lt;col:17&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|     |   `-DeclRefExpr 0x7ffd8f84d828 &lt;col:17&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d570 &apos;b&apos; &apos;int&apos;</span><br><span class="line">|     |-CompoundStmt 0x7ffd8f84d9a0 &lt;col:20, line:8:9&gt;</span><br><span class="line">|     | `-BinaryOperator 0x7ffd8f84d978 &lt;line:7:13, col:21&gt; &apos;int&apos; &apos;=&apos;</span><br><span class="line">|     |   |-DeclRefExpr 0x7ffd8f84d8a8 &lt;col:13&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d4f8 &apos;a&apos; &apos;int&apos;</span><br><span class="line">|     |   `-BinaryOperator 0x7ffd8f84d950 &lt;col:17, col:21&gt; &apos;int&apos; &apos;-&apos;</span><br><span class="line">|     |     |-ImplicitCastExpr 0x7ffd8f84d920 &lt;col:17&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|     |     | `-DeclRefExpr 0x7ffd8f84d8d0 &lt;col:17&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d4f8 &apos;a&apos; &apos;int&apos;</span><br><span class="line">|     |     `-ImplicitCastExpr 0x7ffd8f84d938 &lt;col:21&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|     |       `-DeclRefExpr 0x7ffd8f84d8f8 &lt;col:21&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d570 &apos;b&apos; &apos;int&apos;</span><br><span class="line">|     `-CompoundStmt 0x7ffd8f84dab8 &lt;line:8:16, line:10:9&gt;</span><br><span class="line">|       `-BinaryOperator 0x7ffd8f84da90 &lt;line:9:13, col:21&gt; &apos;int&apos; &apos;=&apos;</span><br><span class="line">|         |-DeclRefExpr 0x7ffd8f84d9c0 &lt;col:13&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d570 &apos;b&apos; &apos;int&apos;</span><br><span class="line">|         `-BinaryOperator 0x7ffd8f84da68 &lt;col:17, col:21&gt; &apos;int&apos; &apos;-&apos;</span><br><span class="line">|           |-ImplicitCastExpr 0x7ffd8f84da38 &lt;col:17&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|           | `-DeclRefExpr 0x7ffd8f84d9e8 &lt;col:17&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d570 &apos;b&apos; &apos;int&apos;</span><br><span class="line">|           `-ImplicitCastExpr 0x7ffd8f84da50 &lt;col:21&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|             `-DeclRefExpr 0x7ffd8f84da10 &lt;col:21&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d4f8 &apos;a&apos; &apos;int&apos;</span><br><span class="line">`-ReturnStmt 0x7ffd8f84db90 &lt;line:12:5, col:12&gt;</span><br><span class="line">`-ImplicitCastExpr 0x7ffd8f84db78 &lt;col:12&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">`-DeclRefExpr 0x7ffd8f84db50 &lt;col:12&gt; &apos;int&apos; lvalue ParmVar 0x7ffd8f84d4f8 &apos;a&apos; &apos;int&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/8/16651a2c89c25804?w=728&amp;h=674&amp;f=jpeg&amp;s=59588" alt=""></p>
<p><br></p>
<h3 id="4⃣-Static-Analysis-静态分析"><a href="#4⃣-Static-Analysis-静态分析" class="headerlink" title="4⃣ Static Analysis - 静态分析"></a>4⃣ Static Analysis - 静态分析</h3><ul>
<li>通过语法树进行代码静态分析，找出非语法性错误</li>
<li>模拟代码执行路径，分析出 control-flow graph (CFG)【MRC下会分析出引用计数的错误】</li>
<li>预置了常用 Checker（检查器）</li>
</ul>
<h3 id="5⃣-中间代码生成"><a href="#5⃣-中间代码生成" class="headerlink" title="5⃣ 中间代码生成"></a>5⃣ 中间代码生成</h3><ul>
<li>CodeGen 负责将语法树从顶至下遍历，翻译成 LLVM IR</li>
<li>LLVM IR 是 Frontend 的输出，也是 LLVM Backend 的输 入，前后端的桥接语言</li>
<li>与 Objective-C Runtime 桥接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>到这一步，LLVM前段编译器clang的工作已经基本做完了。</p>
<p><br><br><br></p>
<h1 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h1><ul>
<li>LLVM IR有3种表示形式,但本质是等价的: </li>
<li><p>text:便于阅读的文本格式，类似于汇编语言，拓展名.ll</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -S -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>
</li>
<li><p>memory:内存格式</p>
</li>
<li>bitcode:二进制格式，拓展名.bc， <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -c -emit-llvm main.m -o main.bc</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h2 id="Optimizer优化器"><a href="#Optimizer优化器" class="headerlink" title="Optimizer优化器"></a>Optimizer优化器</h2><h3 id="SSA-Static-Single-Assignment-静态单一赋值优化"><a href="#SSA-Static-Single-Assignment-静态单一赋值优化" class="headerlink" title="SSA(Static Single Assignment)静态单一赋值优化"></a>SSA(Static Single Assignment)静态单一赋值优化</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>In compiler design, static single assignment form (often abbreviated as SSA form or simply SSA) is a property of an intermediate representation (IR), which requires that each variable is assigned exactly once, and every variable is defined before it is used.<br><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; – From Wikipedia</p>
</blockquote>
<p>从上面的描述可以看出，SSA 形式的 IR 主要特征是每个变量只赋值一次。相比而言，非SSA形式的IR里一个变量可以赋值多次。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p> 可以简化很多编译优化方法的过程；<br><br> 对很多编译优化方法来说，可以获得更好的优化结果,<br></p>
<p>下面给出一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">int x, y;</span><br><span class="line">x = 1;</span><br><span class="line">x = 2;</span><br><span class="line">y = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>非SSA<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y := 1</span><br><span class="line">y := 2</span><br><span class="line">x := y</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>显然，我们一眼就可以看出，上述代码第一行的赋值行为是多余的，第三行使用的 y 值来自于第二行中的赋值。对于采用非 SSA 形式 IR 的编译器来说，它需要做数据流分析（具体来说是到达-定义分析）来确定选取哪一行的 y 值。但是对于 SSA 形式来说，就不存在这个问题了。如下所示：</p>
</blockquote>
<ul>
<li>SSA<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y1 := 1</span><br><span class="line">y2 := 2</span><br><span class="line">x1 := y2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>我们不需要做数据流分析就可以知道第三行中使用的y来自于第二行的定义，这个例子很好地说明了SSA的优势。除此之外，还有许多其他的优化算法在采用SSA形式之后优化效果得到了极大提高。甚至，有部分优化算法只能在SSA上做。</p>
</blockquote>
<ul>
<li>这里 LLVM 会去做些优化工作，在Xcode的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass — LLVM 5 documentation</a>  </li>
</ul>
<p>优化IR：(级别-03)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</li>
</ul>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。  </p>
<p>生成字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.m -o main.bc</span><br></pre></td></tr></table></figure></p>
<p>注：xx.bc文件是位流格式，由于是二进制的，所以直接看就是一堆乱码，查看bitcode最好的方式是用hexdump工具。</p>
<p><br></p>
<h3 id="6⃣-Assemble-生成Target相关汇编"><a href="#6⃣-Assemble-生成Target相关汇编" class="headerlink" title="6⃣ Assemble -生成Target相关汇编"></a>6⃣ Assemble -生成Target相关汇编</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure>
<h3 id="7⃣-Assemble-生成-Target-相关机器码-Object-Mach-O"><a href="#7⃣-Assemble-生成-Target-相关机器码-Object-Mach-O" class="headerlink" title="7⃣ Assemble - 生成 Target 相关机器码 Object (Mach-O)"></a>7⃣ Assemble - 生成 Target 相关机器码 Object (Mach-O)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure>
<h3 id="8⃣-Link-生成-Executable-可执行文件"><a href="#8⃣-Link-生成-Executable-可执行文件" class="headerlink" title="8⃣  Link 生成 Executable 可执行文件"></a>8⃣  Link 生成 Executable 可执行文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang main.o -o main</span><br><span class="line">执行</span><br><span class="line">./main</span><br><span class="line">输出</span><br><span class="line">starming rank 14</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="总结：Clang-LLVM-下，一个源文件的编译过程"><a href="#总结：Clang-LLVM-下，一个源文件的编译过程" class="headerlink" title="总结：Clang-LLVM 下，一个源文件的编译过程:"></a>总结：Clang-LLVM 下，一个源文件的编译过程:</h2><p><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652bcd7a26e0a5?w=904&amp;h=489&amp;f=jpeg&amp;s=72140" alt=""></p>
<h4 id="整个工作流程犹如："><a href="#整个工作流程犹如：" class="headerlink" title="整个工作流程犹如："></a>整个工作流程犹如：</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a04a63cb2dbf4?w=1470&amp;h=482&amp;f=jpeg&amp;s=139239" alt=""></p>
<h2 id="完整的编译过程"><a href="#完整的编译过程" class="headerlink" title="完整的编译过程"></a>完整的编译过程</h2><p>1.优先编译cocopods里面的所有依赖文件<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652d974654bb57?w=884&amp;h=817&amp;f=jpeg&amp;s=195377" alt=""><br>2.编译信息写入辅助信息，创建编译后的文件架构<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652d4c28a29575?w=1041&amp;h=139&amp;f=jpeg&amp;s=66257" alt=""><br>3.处理打包信息。例如development环境下处理xxxx.entitlements的打包信息<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652e83854f69cb?w=1013&amp;h=257&amp;f=jpeg&amp;s=85015" alt=""><br>4.执行cocopods编译前脚本 checkPods Manifest.lock<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652dc5d6876eae?w=1005&amp;h=118&amp;f=jpeg&amp;s=67883" alt=""><br>5.编译包内所有m文件 （使用Compile和Clang的几个主要命令）<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652ddb40d2ea98?w=1026&amp;h=124&amp;f=jpeg&amp;s=46049" alt=""><br>6.链接需要的framework，例如AFNetworking.framework，Masonry.framework等信息<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652e0442493795?w=1013&amp;h=104&amp;f=jpeg&amp;s=70843" alt=""><br>7.编译xib文件<br>8.copy Xib文件，图片等资源文件放到结果目录<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652eeb1656d29f?w=1018&amp;h=45&amp;f=jpeg&amp;s=32721" alt=""><br>9.编译imageAsserts<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652ee5d7e9f1c4?w=1013&amp;h=26&amp;f=jpeg&amp;s=12456" alt=""><br>10.处理infoplist<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652ede99e38ebd?w=1000&amp;h=29&amp;f=jpeg&amp;s=20039" alt=""><br>11.执行Cocoapods脚本<br>12.copy标准库<br>13.创建.app文件和签名<br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652ebfdacf7e40?w=1013&amp;h=205&amp;f=jpeg&amp;s=116721" alt=""><br><br></p>
<p><strong>我的深圳编译流程：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/10/8/16652ea8ff0b2227?w=1380&amp;h=985&amp;f=jpeg&amp;s=546283" alt=""></p>
<p><br></p>
<h2 id="clang插件开发"><a href="#clang插件开发" class="headerlink" title="clang插件开发"></a>clang插件开发</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><p>安装brew</p>
<blockquote>
<p>brew是一个软件包管理工具,类似于centos下的yum或者ubuntu下的apt-get,非常方便,免去了自己手动编译安装的不便<br>brew 安装目录 /usr/local/Cellar<br>brew 配置目录 /usr/local/etc<br>brew 命令目录 /usr/local/bin<br>注:homebrew在安装完成后自动在/usr/local/bin加个软连接，所以平常都是用这个路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>安装cmake</p>
<blockquote>
<p>CMake是一个跨平台的编译(Build)工具,可以用简单的语句来描述所有平台的编译过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install cmake</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>安装ninja</p>
<blockquote>
<p>Ninja 是一个构建系统，与 Make 类似。作为输入，你需要描述将源文件处理为目标文件这一过程所需的命令。 Ninja 使用这些命令保持目标处于最新状态。<br>Ninja 的主要设计目标是速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install ninja</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p><br></p>
<h3 id="下载编译工具"><a href="#下载编译工具" class="headerlink" title="下载编译工具"></a>下载编译工具</h3><ul>
<li><p>下载LLVM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 大小648.2M</span><br><span class="line">$ git clone https://git.llvm.org/git/llvm.git/</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载clang</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 大小240.6M</span><br><span class="line">$ cd llvm/tools</span><br><span class="line">$ git clone https://git.llvm.org/git/clang.git/</span><br></pre></td></tr></table></figure>
</li>
<li><p>在LLVM源码同级目录下新建一个【llvm_build】目录(最终会在【llvm_build】目录下生成【build.ninja】)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd llvm_build</span><br><span class="line">$ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=LLVM的安装路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>依次执行编译、安装指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ninja</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>编译完毕后， 【llvm_build】目录大概 21.05 G(仅供参考)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ninja install</span><br></pre></td></tr></table></figure></p>
<p>安装完毕后，安装目录大概 11.92 G(仅供参考)</p>
<ul>
<li>在llvm同级目录下新建一个【llvm_xcode】目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd llvm_xcode</span><br><span class="line">$ cmake -G Xcode ../llvm</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h2 id="开始开发插件"><a href="#开始开发插件" class="headerlink" title="开始开发插件"></a>开始开发插件</h2><ul>
<li><p>在【llvm/tools/clang/tools】源码目录下新建一个插件目录，假设叫做【yb-plugin】<br><img src="https://user-gold-cdn.xitu.io/2018/9/30/166290b28aa24291?w=1023&amp;h=478&amp;f=jpeg&amp;s=159389" alt=""></p>
</li>
<li><p>在【llvm/tools/clang/tools/CMakeLists.txt】最后加入内容: add_clang_subdirectory(yb-plugin)，小括号里是插件目录名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># libclang may require clang-tidy in clang-tools-extra.</span><br><span class="line">add_clang_subdirectory(libclang)</span><br><span class="line">add_clang_subdirectory(yb-plugin)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在【yb-plugin】目录下新建一个【YBPlugin.cpp】和【CMakeLists.txt】，并在【CMakeLists.txt】文件里面添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_loadable_module(YBPlugin YBPlugin.cpp)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>MJPlugin是插件名，MJPlugin.cpp是源代码文件</p>
</blockquote>
<p><br></p>
<h2 id="编译插件"><a href="#编译插件" class="headerlink" title="编译插件"></a>编译插件</h2><blockquote>
<h3 id="生成xcode项目"><a href="#生成xcode项目" class="headerlink" title="生成xcode项目"></a>生成xcode项目</h3><ul>
<li>利用cmake生成的Xcode项目来编译插件(第一次编写完插件，需要利用cmake重新生成一下Xcode项目)<h3 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h3></li>
<li>插件源代码在【Sources/Loadable modules】目录下可以找到，这样就可以直接在Xcode里编写插件代码<h3 id="编译插件生成动态库文件"><a href="#编译插件生成动态库文件" class="headerlink" title="编译插件生成动态库文件"></a>编译插件生成动态库文件</h3></li>
<li>选择MJPlugin这个target进行编译，编译完会生成一个动态库文件，将动态库文件存放在桌面。</li>
</ul>
</blockquote>
<p><br></p>
<h2 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h2><ul>
<li>在Xcode项目中指定加载插件动态库:BuildSettings &gt; OTHER_CFLAGS<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/30/166291e5febbc175?w=2048&amp;h=986&amp;f=jpeg&amp;s=247798" alt=""></p>
<p><br></p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><ul>
<li>首先要对Xcode进行Hack，才能修改默认的编译器<blockquote>
<p>下载【XcodeHacking.zip】，解压，修改【HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec】的内容，设<br>置一下自己编译好的clang的路径<br><img src="https://user-gold-cdn.xitu.io/2018/9/30/16629249474c657f?w=2048&amp;h=795&amp;f=jpeg&amp;s=214089" alt=""></p>
</blockquote>
</li>
<li><p>然后在XcodeHacking目录下进行命令行，将XcodeHacking的内容剪切到Xcode内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv HackedClang.xcplugin `xcode-select-print- path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins</span><br><span class="line">$ sudo mv HackedBuildSystem.xcspec `xcode-select-print- path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置项目<br><img src="https://user-gold-cdn.xitu.io/2018/9/30/16629293f12beaa9?w=1966&amp;h=734&amp;f=jpeg&amp;s=204046" alt=""></p>
</li>
</ul>
<p><br></p>
<h2 id="插件效果"><a href="#插件效果" class="headerlink" title="插件效果"></a>插件效果</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/30/166291f2bacc5e05?w=2022&amp;h=1262&amp;f=jpeg&amp;s=425240" alt=""></p>
<p><br></p>
<p><br></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p> <a href="">clang插件编写</a></p>
<p> <a href="https://github.com/obfuscator-llvm/obfuscator/wiki" target="_blank" rel="noopener">代码混淆</a></p>
<p> <a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488360&amp;idx=1&amp;sn=94fba30a87d0f9bc0b9ff94d3fed3386&amp;source=41#wechat_redirect" target="_blank" rel="noopener">APP包瘦身</a></p>
<p> <a href="https://blog.csdn.net/guojin08/article/details/54310858" target="_blank" rel="noopener">iOS动态化方案——OCS</a></p>
<p> <a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">开发新的编程语言</a> </p>
<p><br></p>
<p><br></p>
<h1 id="推荐书记"><a href="#推荐书记" class="headerlink" title="推荐书记"></a>推荐书记</h1><p><img src="https://user-gold-cdn.xitu.io/2018/9/30/166294c4bc43de48?w=1154&amp;h=559&amp;f=jpeg&amp;s=154084" alt=""></p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/10/14/2018/10/Cocoapod建立自己的仓库/" title="CocoaPods建立自己的仓库">CocoaPods建立自己的仓库</a></h2>
                <p class="excerpt">
                
                
前序作为iOS开发，无论你是小白还是远古时代MRC的大神，相信没有人不知道CocoaPods，如果不知道的话，那么你应该去面壁十分钟怀疑自己了～github几乎所有（或者说全部）优秀的iOS开源框架都提供了Cocoapods Installation方式，由此可见，CocoaPods的使用为我们开
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-10-14T11:11:15.000Z" class="post-list__meta--date date">2018-10-14</time> &#8226; <span class="post-list__meta--tags tags"> 
  
</span><a class="btn-border-small" href="/2018/10/14/2018/10/Cocoapod建立自己的仓库/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/11/26/2017/11/开发中用到的工具记录/" title="开发中用到的工具记录">开发中用到的工具记录</a></h2>
                <p class="excerpt">
                
                
 记录一下在开发的过程中使用到的一些小工具，这些小工具给我们带来了极大的便利。 (什么Xcode、Git、CocoaPods等就不写了，基本配置)
go2shellGo2Shell 可以在 Finder 中打开当前目录的终端窗口，是一个对开发者来说非常有用的App。特点：软件开发工具、小巧（大概只
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-11-26T03:21:19.000Z" class="post-list__meta--date date">2017-11-26</time> &#8226; <span class="post-list__meta--tags tags"> 
  
</span><a class="btn-border-small" href="/2017/11/26/2017/11/开发中用到的工具记录/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

            <footer class="footer">
    <span class="footer__copyright">
        &copy; Bryan Yang - xxzizixx@163.com
       
    </span>

    <span class="footer__copyright">
          知识需要分享，很高兴能和大家一起探讨。如需转载，请注明出处，谢谢。
       
    </span>

    <span class="footer__copyright">
              如有疑问，请邮件我，看到后会第一时间回复您。祝您阅读愉快！
         </span>
       
    
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
